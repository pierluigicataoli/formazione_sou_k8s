# Specifica l'immagine Docker da distribuire.
image:
  # Usa il nome dell'immagine creata dalla tua pipeline
  repository: flask-app-example-build 
  
  # Questo è il valore cruciale che l'utente può sovrascrivere.
  # Ad esempio, 'latest' o un hash di commit specifico.
  tag: latest 
  
  # Strategia di pull dell'immagine
  pullPolicy: IfNotPresent

# Numero di repliche
replicaCount: 2

# Configurazione del Service Kubernetes (come esporre l'app)
service:
  type: LoadBalancer # o ClusterIP se non vuoi che sia accessibile dall'esterno
  port: 80
  targetPort: 5000 # Porta predefinita di un'app Flask
  serviceAccount:
  # Questa proprietà 'create' è quella che mancava. 
  # Senza di essa, il template ServiceAccount non riesce a leggere '.create'.
  create: true
ingress:
  enabled: false 
  className: ""
  annotations: {}
  hosts: []
httpRoute:
  enabled: false
autoscaling:
  # 'enabled' è la proprietà che mancava. 
  # Impostalo su 'false' se non vuoi usare l'autoscaling.
  enabled: false 
  
  # Aggiungi qui le proprietà min/max che il template si aspetta (anche se disabilitato)
  minReplicas: 1
  maxReplicas: 3
  targetCPUUtilizationPercentage: 80
resources:
  limits:
    cpu: 200m
    memory: 256Mi
  requests:
    cpu: 100m
    memory: 128Mi

# 2. Probes (Liveness e Readiness)
# Queste configurazioni permettono a Kubernetes di sapere se l'app è viva e pronta a ricevere traffico.
probes:
  enabled: true
  
  liveness:
    path: /
    port: http # Deve corrispondere al nome della porta nel deployment
    initialDelaySeconds: 10
    periodSeconds: 5
    
  readiness:
    path: /
    port: http
    initialDelaySeconds: 5
    periodSeconds: 5
