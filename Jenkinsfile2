pipeline {
    // Definizione dell'agente Kubernetes per eseguire i comandi
    agent {
        kubernetes {
            // Container sidecar con Helm, Kubectl e il client Docker
            yaml """
apiVersion: v1
kind: Pod
metadata:
  namespace: formazione-sou
spec:
  serviceAccountName: jenkins-sa
  volumes:
  - name: docker-socket
    hostPath:
      path: /var/run/docker.sock 
  containers:
  - name: jnlp
    image: jenkins/inbound-agent:latest
  - name: helm-kubectl
    image: alpine:latest 
    command: ['cat']
    tty: true
  - name: docker-cli
    image: docker:cli
    command: ['cat']
    tty: true
    volumeMounts:
    - name: docker-socket
      mountPath: /var/run/docker.sock 
"""
            namespace 'formazione-sou'
        }
    }

    // Variabili d'ambiente
    environment {
        K8S_NAMESPACE = 'formazione-sou'
        CHART_PATH = 'charts/flask-app-chart'
        HELM_RELEASE_NAME = 'sou-app-release'
        GIT_REPO_URL = 'https://github.com/pierluigicataoli/formazione_sou_k8s.git'
        GIT_CREDENTIALS_ID = 'github-token-pierluigi'
        IMAGE_NAME = 'flask-app-example-build'
        IMAGE_TAG = 'latest'
    }

    // Stage
    stages {
        stage('Checkout & Setup') {
            steps {
                script {
                    // *** CHECKOUT ESPLICITO SPOSTATO QUI ***
                    // Questo garantisce che i file siano scaricati nella cartella di lavoro visibile a tutti i container sidecar.
                    checkout([$class: 'GitSCM', branches: [[name: '*/main']], extensions: [], userRemoteConfigs: [[credentialsId: env.GIT_CREDENTIALS_ID, url: env.GIT_REPO_URL]]])
                }
                echo "Esecuzione deploy nel namespace: ${K8S_NAMESPACE}"
            }
        }

        stage('Docker Build & Load') {
            steps {
                container('docker-cli') {
                    sh "docker build -t ${IMAGE_NAME}:${IMAGE_TAG} ."
                }
            }
        }

        stage('Helm Deploy') {
                    options {
                retry(2) 
            }
            steps {
                container('helm-kubectl') {
                    sh 'apk update && apk add --no-cache curl helm kubectl'
                    // Esegue l'installazione o l'aggiornamento del chart Helm senza --wait
                    sh """
                    helm upgrade --install \\
                        ${HELM_RELEASE_NAME} \\
                        ./${CHART_PATH} \\
                        --namespace ${K8S_NAMESPACE}
                    """
                }
            }
        }
        
        // =================================================================
        // NUOVO STAGE: Quality Gates
        // =================================================================
        stage('Quality Gates') {
            steps {
                container('helm-kubectl') {
                    // 1. Rendiamo lo script eseguibile
                    sh 'chmod +x script_5'
                    
                    // 2. Installiamo jq (necessario per l'analisi JSON)
                    sh 'apk add --no-cache jq' 
                    
                    // 3. Eseguiamo il controllo. Fallir√† se mancano i parametri.
                    sh './script_5'
                }
            }
        }
    }
}
